<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://preaction.github.io/blog/tag/perl/index.html</id>
    <title>preaction</title>
    <updated>2015-01-21T22:39:30Z</updated>
    <link rel="self" href="http://preaction.github.io/blog/tag/perl.atom"/>
    <link rel="alternate" href="http://preaction.github.io/blog/tag/perl/index.html"/>
    <generator version="0.034">Statocles</generator>
    <entry>
        <id>http://preaction.github.io/blog/2015/01/21/managing-sql-data-with-yertl.html</id>
        <title>Managing SQL Data with Yertl</title>
        <link rel="alternate" href="http://preaction.github.io/blog/2015/01/21/managing-sql-data-with-yertl.html" />
        <content type="html"><![CDATA[
            <p>Every week, I work with about a dozen SQL databases. Some are Sybase, some
MySQL, some SQLite. Some have different versions in dev, staging, and
production. All of them need data extracted, transformed, and loaded.</p>

<p>DBI is the clear choice for dealing with SQL databases in Perl, but there are a
dozen lines of Perl code in between me and the operation that I want. Sure,
I've got modules and web applications and ad-hoc commands and scripts that
perform certain individual tasks on my databases, but sometimes those things
don't quite do what I need right now, and I just want something that will let
me execute whatever SQL I can come up with.</p>

<p><a href="http://metacpan.org/pod/ETL::Yertl">Yertl (ETL::Yertl)</a> is a shell-based ETL
framework. It's under development (as is all software), but included already is
a small utility called <a href="http://metacpan.org/pod/ysql">ysql</a> to make dealing
with SQL databases easy.</p>

<p>To use ysql, first we have to configure a database. This saves us from having
to type the full DBI data source name (dbi:mysql:host=dev;database=mydb) every
time. Instead, we can refer to our database by a nice name, like "dev", or
"prod".</p>

<pre><code>$ ysql config dev dbi:SQLite:database.db
</code></pre>

<p>Later, we can update our configuration if we need to:</p>

<pre><code>$ ysql config dev --database=dev.db
</code></pre>

<p>We can examine our configuration as a YAML document:</p>

<pre><code>$ ysql config dev
---
database: dev.db
driver: SQLite
</code></pre>

<p>Let's add a production database as well:</p>

<pre><code>$ ysql config prod --driver=SQLite --database=prod.db
</code></pre>

<p>And now we can check both of our configs:</p>

<pre><code>$ ysql config
---
dev:
  database: dev.db
  driver: SQLite
prod:
  database: prod.db
  driver: SQLite
</code></pre>

<p>Now that we've configured some databases, let's insert some data. First we need
to make some tables:</p>

<pre><code>$ ysql query prod 'CREATE TABLE users ( id INTEGER PRIMARY KEY \
    AUTOINCREMENT, name VARCHAR, email VARCHAR )'
$ ysql query dev 'CREATE TABLE users ( id INTEGER PRIMARY KEY \
    AUTOINCREMENT, name VARCHAR, email VARCHAR )'
</code></pre>

<p>Next let's insert some data:</p>

<pre><code>$ ysql query prod 'INSERT INTO users ( name, email ) \
    VALUES ( "preaction", "preaction@example.com" )'
$ ysql query prod 'INSERT INTO users ( name, email ) \
    VALUES ( "postaction", "postaction@example.com" )'
</code></pre>

<p>Now, let's query for our data:</p>

<pre><code>$ ysql query prod 'SELECT * FROM users'
---
email: preaction@example.com
id: 1
name: preaction
---
email: postaction.example.com
id: 2
name: postaction
</code></pre>

<p>Yertl uses YAML as its default output, but we can easily convert to JSON or CSV
using the <a href="http://metacpan.org/pod/yto">yto utility</a></p>

<pre><code>$ ysql query prod 'SELECT * FROM users' | yto csv
email,id,name
preaction@example.com,1,preaction
postaction@example.com,2,postaction

$ ysql query prod 'SELECT * FROM users' | yto json
{
   "email" : "preaction@example.com",
   "id" : "1",
   "name" : "preaction"
}
{
   "email" : "postaction@example.com",
   "id" : "2",
   "name" : "postaction"
}
</code></pre>

<p>Now, lets say we want to copy our production database to dev for testing. To do
that, Yertl allows us to read YAML from STDIN and execute a query for each YAML
document. Yertl uses a special interpolation syntax (starting with a "$") to
pick parts of the document to fill in the query:</p>

<pre><code>$ ysql query prod 'SELECT * FROM users' |
    ysql query dev 'INSERT INTO users ( id, name, email ) \
        VALUES ( $.id, $.name, $.email )'
</code></pre>

<p>So this will take our users table from prod and write it to dev. '$.id' picks
the "id" field, '$.name' the "name" field, etc...</p>

<p>But all this would be a bear to type over and over again (imagine if we had a
bunch of joins to do). So, ysql allows you to save queries for later use using
the <code>--save &lt;name&gt;</code> option:</p>

<pre><code>$ ysql query prod --save users 'SELECT * FROM users'
$ ysql query dev --save update_users 'UPDATE users SET \
    name=$.name, email=$.email WHERE id=$.id'
</code></pre>

<p>Then we can recall our query by the name we gave to the <code>--save</code> option:</p>

<pre><code>$ ysql query prod users | ysql query dev update_users
</code></pre>

<p>Finally, using yto and <a href="http://metacpan.org/pod/yfrom">yfrom</a>, we can write a
dump of our users to JSON, and then read that database dump back into our
database:</p>

<pre><code>$ ysql query prod users | yto json &gt; users.json
$ yfrom json &lt; users.json | ysql query dev update_users
</code></pre>

<p>So, though Yertl is in its infancy, it can already help with some common
database tasks!</p>

<p>There are lots of <a href="https://github.com/preaction/ETL-Yertl/labels/feature">plans for Yertl, described in the feature's tag on the issue
tracker</a>, so if you've
got common data tasks that you feel should be easier, <a href="https://chat.mibbit.com/?channel=%23yertl&amp;server=irc.perl.org">join me in #yertl on
irc.perl.org</a>.</p>

                <p><a href="http://preaction.github.io/blog/2015/01/21/managing-sql-data-with-yertl.html#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="/blog/tag/perl/index.html">perl</a>
                <a href="/blog/tag/sql/index.html">sql</a>
                <a href="/blog/tag/etl/index.html">etl</a>
                <a href="/blog/tag/yertl/index.html">yertl</a>
            </p>
        ]]></content>
        <updated>2015-01-21T00:00:00Z</updated>
        <category term="Statocles::Link=HASH(0x7fd1018b4048)" />
        <category term="Statocles::Link=HASH(0x7fd1018b4498)" />
        <category term="Statocles::Link=HASH(0x7fd1018b47b0)" />
        <category term="Statocles::Link=HASH(0x7fd1018b4a68)" />
    </entry>
    <entry>
        <id>http://preaction.github.io/blog/2014/10/26/managing-boilerplate-with-import-base.html</id>
        <title>Manage Boilerplate with Import::Base</title>
        <author><name>preaction</name></author>
        <link rel="alternate" href="http://preaction.github.io/blog/2014/10/26/managing-boilerplate-with-import-base.html" />
        <content type="html"><![CDATA[
            <p>Boilerplate is everything I hate about programming:</p>

<ul>
<li>Doing the same thing more than once</li>
<li>Leaving clutter in every file</li>
<li>Making it harder to change things in the future</li>
<li>Eventually blindly copying without understanding (cargo-cult programming)</li>
</ul>

<p>In an effort to reduce some of my boilerplate, I wrote
<a href="https://metacpan.org/pod/Import::Base">Import::Base</a>, a module to collect and
import useful bundles of modules, removing the need for long lists of <code>use ...</code>
lines everywhere.</p>

                <ul>
                    <li><a href="http://blogs.perl.org/users/preaction/2014/10/managing-boilerplate-with-importbase.html">
                        Continue reading <em>Manage Boilerplate with Import::Base</em> on blogs.perl.org...
                    </a></li>
                    <li><a href="http://preaction.github.io/blog/2014/10/26/managing-boilerplate-with-import-base.html#section-2">
                        Continue reading on preaction
                    </a></li>
                </ul>
            <p>Tags:
                <a href="/blog/tag/perl/index.html">perl</a>
            </p>
        ]]></content>
        <updated>2014-10-26T00:00:00Z</updated>
        <category term="Statocles::Link=HASH(0x7fd1018b34e0)" />
    </entry>
    <entry>
        <id>http://preaction.github.io/blog/2014/06/14/conflict-resolution-local--lib-and-gits-perl.html</id>
        <title>Conflict Resolution: local::lib and git's Perl</title>
        <author><name>preaction</name></author>
        <link rel="alternate" href="http://preaction.github.io/blog/2014/06/14/conflict-resolution-local--lib-and-gits-perl.html" />
        <content type="html"><![CDATA[
            <p>I ran into a frustrating problem the other day:</p>

<pre><code>$ git add -i
/usr/bin/perl: symbol lookup error: ~/perl5/lib/perl5/x86_64-linux-thread-multi/auto/List/Util/Util.so:
undefined symbol: Perl_xs_apiversion_bootcheck
fatal: 'add--interactive' appears to be a git command, but we were not
able to execute it. Maybe git-add--interactive is broken?
</code></pre>

                <ul>
                    <li><a href="http://blogs.perl.org/users/preaction/2014/06/conflict-resolution-locallib-and-gits-perl.html">
                        Continue reading <em>Conflict Resolution: local::lib and git's Perl</em> on blogs.perl.org...
                    </a></li>
                    <li><a href="http://preaction.github.io/blog/2014/06/14/conflict-resolution-local--lib-and-gits-perl.html#section-2">
                        Continue reading on preaction
                    </a></li>
                </ul>
            <p>Tags:
                <a href="/blog/tag/perl/index.html">perl</a>
                <a href="/blog/tag/git/index.html">git</a>
            </p>
        ]]></content>
        <updated>2014-06-14T00:00:00Z</updated>
        <category term="Statocles::Link=HASH(0x7fd1018b1918)" />
        <category term="Statocles::Link=HASH(0x7fd1018b1dc8)" />
    </entry>
    <entry>
        <id>http://preaction.github.io/blog/2012/03/20/adventures-in-debugging-c-xs-2-debugging-boogaloo.html</id>
        <title>Adventures in Debugging C/XS 2: Debugging Boogaloo</title>
        <author><name>preaction</name></author>
        <link rel="alternate" href="http://preaction.github.io/blog/2012/03/20/adventures-in-debugging-c-xs-2-debugging-boogaloo.html" />
        <content type="html"><![CDATA[
            <p>... or "Ask Not To Whom The Pointer Points, It Points To Thee."</p>

<p>TL;DR: A pointer is not a reference. A pointer knows nothing about the data
being pointed to. Returning multiple values requires actual work.</p>

<p>Everything went wrong when I wanted a string with a <code>NUL</code> character inside it.
C strings are not Perl scalars, they don't know how long they are. So to mark
the end of a string, C uses the <code>NUL</code> character, <code>\0</code>. The <code>strcpy</code> function will
copy to your destination until the first <code>\0</code> from your source. When you want to
have a string with a <code>\0</code> inside of it that does not mark the end of the string,
you need to know exactly how long the string is. This is not difficult to do,
but you also have to return that length from the function that creates your
string.</p>

<p>C functions do not have more than one return value.</p>

<pre><code>(char* buffer, int bufferSize) = get_string_with_nuls();
// You thought it could be that easy?
</code></pre>

<p>So in order for your function to result in more than one value, you have to
pass in references to be used to fill in with actual values.</p>

<pre><code>char* buffer;
int bufferSize = get_string_with_nuls( buffer );
// C programmers will already know what I did wrong here
</code></pre>

<p>Thinking like a Perl programmer, I thought I could just pass in the pointer to
the function and the function could fill it with data. Two problems:</p>

<ol>
<li>I passed in the pointer itself, not a reference to the pointer: <code>&amp;buffer</code></li>
<li>I did not initialize the pointer to anything.</li>
</ol>

<p>A more correct way would be:</p>

<pre><code>char* buffer = malloc( 128 * sizeof( char ) );
int bufferSize = get_string_with_nuls( &amp;buffer );
</code></pre>

<p>But this suffers from another problem: I have to know beforehand how big my
string is going to be and allocate that much memory beforehand.</p>

<p>The way I ended up succeeding was:</p>

<pre><code>int bufferSize;
char* buffer = get_string_with_nuls( &amp;bufferSize );
</code></pre>

<p>This way, <code>get_string_with_nuls</code> can handle the <code>malloc</code> with exactly the correct
size and give it to me. I don't have to guess at a size beforehand.</p>

<p>Of course, a struct could do this better, or since I'm actually in C++, an
object. I'll be planning a new API as soon as I confirm this one actually
works and has proper tests (written in Perl, of course).</p>

                <p><a href="http://preaction.github.io/blog/2012/03/20/adventures-in-debugging-c-xs-2-debugging-boogaloo.html#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="/blog/tag/perl/index.html">perl</a>
                <a href="/blog/tag/xs/index.html">xs</a>
            </p>
        ]]></content>
        <updated>2012-03-20T00:00:00Z</updated>
        <category term="Statocles::Link=HASH(0x7fd1018a3d10)" />
        <category term="Statocles::Link=HASH(0x7fd10189e3a8)" />
    </entry>
</feed>

